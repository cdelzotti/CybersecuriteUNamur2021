
    {
        "name" : "Matière du cours de Sécurité, juin 2021, Chapitre 8",
        "elements" : [
            {
                "value" : "Quelles sont les différentes étapes du cycle de vie d'un logiciel (SDLC) et quels sont les mesures applicables à chacune d'entre elles ?",
                "answer" : "1. Analyse des exigences\n    -> Mesures applicables: Misuse cases, exigences de sécurité, analyse de risques\n2. Architecture, design, conception\n    -> Mesures applicables: analyse de risques\n3. Elaboration de plans de test\n    -> Mesures applicables: concentrer l'effort de tests sur les risques\n4. Développement du code\n    -> Mesures applicables: review du code (par d'autres personnes ou avec des outils)\n5. Exécution des plans de tests\n    -> Mesures applicables: analyse de risques, penetration testing\n6. Mise en production\n    -> Mesures applicables: penetration testing, bonnes pratiques de déploiement\n\nSur tout le cycle: external review, soumettre l'architecture à un collègue/équipe spécialisée pour faire une review de la sécurité"
            },
            {
                "value": "Qu'est-ce que le modèle du \"misuse case\" ? À quoi ça sert ?",
                "answer": "C'est une extension UML du modèle \"use case\" classique qui permet de détailler les vulnérabilités potentielles et la manière dont on y remédie dès la phase de spécification.\n\nVoir l'image \"misuse-case-example.png\" pour un exemple de diagramme.\n\n    -> À l'examen, il faut \"savoir compléter un cas d'utilisation par les comportements malicieux et de remédiation selon l'approche des misuse case\"."
            },
            {
                "value": "Qu'est-ce qu'un \"misuse case\" ?",
                "answer": "Contrairement au \"use case\" qui est un comportement attendu du système, un \"misuse case\" est un comportement contre lequel le système doit se protéger.\n\nEn UML, c'est un ovale avec un fond gris. (voir l'image \"misuse-case-example.png\")"
            },
            {
                "value": "Qu'est-ce qu'un \"misuser\" ?",
                "answer": "Dans le modèle du \"misuse case\", un \"misuser\" est le pendant hostile d'un \"user\". Les \"user\" peuvent réaliser des \"use cases\", un \"misuser\" réalise des \"misuse cases\". En gros, c'est l'attaquant.\n\nEn UML c'est un petit bonhomme noir pcq UML est raciste. (voir l'image \"misuse-case-example.png\")"
            },
            {
                "value": "Quelles sont les relations que les \"use cases\" et \"misuse cases\" peuvent avoir entre eux ?",
                "answer": "Il y en a 2:\n    - \"threatens\": Un \"misuse case\" menace un \"use case\"\n    - \"mitigates\": Un \"use case\" peut mitiger/pallier un \"misuse case\"\n\nEn UML, c'est juste une flèche avec le nom marqué à côté (voir l'image \"misuse-case-example.png\")."
            },
            {
                "value": "Quelles sont les grands types de vulnérabilités logicielles et les manières d'y remédier ?",
                "answer": "- Données non vérifiées (Injection, XSS, problèmes d'encoding...)\n    -> Vérifier les données ! (qu'elles soient conformes, leur origine, leur cible, la syntaxe, la sémantique...)\n        - On valide les données avant de les donner à un module, et parfois également en sortie du module\n        - Différentes approches:\n            - Rejeter les valeurs qui sont mauvaise ? (reject known bad, blacklist)\n            - N'accepter que les valeurs qui sont correctes ? (accept known good, whitelist)\n            - Sanitization (enlever les caractères potentiellement dangereux (ex: < > pour XSS))\n- Concurrence d'accès (Deadlock, perte d'info, perte d'intégrité, ...)\n    -> Utiliser des mécanismes de synchronisation (sémaphores, locks, ...)\n    -> Minimiser le temps entre le check et l'accès (TOCTTOU)\n    -> Idéalement: Check, Access, Check\n- Authentification\n    -> Utiliser des mécanismes existant et éprouvés si possible\n    -> Utiliser des connexions chiffrées (confidentialité)\n    -> CAPTCHA pour éviter les brute force et le vol d'information\n- Autorisation\n    -> utiliser un modèle éprouvé et approprié\n    -> Tous les accès doivent passer par le garde\n- Cryptographie\n    -> utiliser des algorithmes éprouvés\n    -> vérifier régulièrement qu'ils sont toujours à jour\n    -> attention en PRNG, au stockage des clés et infos confidentielles...\n- Composants tiers\n    -> vérifier qu'ils sont sûrs et maintenus avant de les utiliser\n    -> valider leur dépendances, notamment lors de mises à jours\n- Déploiement\n    -> Vérifier si l'environnement de déploiement est sécurisé\n    -> Configuration sûre (avoir modifié les mdp par défauts, ...)\n    -> N'activer que les composants nécessaires\n    -> Limiter l'accès aux panneau admin et au VPS (ex: limiter à certaines IP, mettre en local...)\n    -> Séparer les composants (par exemple dans des containers docker)"
            },
            {
                "value": "Quelles sont les principales bonnes pratiques de conception pour sécuriser un logiciel ?",
                "answer": "- Le programme doit être aussi simple que possible\n- Ne jamais faire confiance à personne (ni aux utilisateurs, ni à l'environnement (e.g. supposer qu'un fichier se trouve là où on pense)). Il faut toujours vérifier.\n- Défense en profondeur: il faut différentes couches de sécurité\n- Toujours commencer par se concentrer sur le maillon faible (\"ça ne sert à rien de sur-sécuriser quelque chose qui est déjà blindé s'il y a à côté une porte qui permet d'y accéder et qui n'est absolument pas sécurisée\")\n- C'est pas parce qu'un code ou algorithme est caché qu'il est infaillible (no security by obscurity)\n - Prendre en compte que les utilisateurs doivent accepter certaines mesures (ex: ils auront du mal à accepter de changer de mdp tous les jours)"
            }, {
                "value": "Quelles sont les bonnes pratiques de conception pour sécuriser un logiciel par rapport au contrôle d'accès ? (Access Control)",
                "answer": "- un utilisateur doit avoir un minimum de privilèges pour un temps minimal\n- Séparer les zones de permissions, ségrégation des rôles\n- Séparations en modules isolés\n- Tous les accès doivent être contrôlés par le garde (mécanisme de contrôle)\n- Attention à TOCTTOU (time of check to time of use): Checker les permissions à chaque utilisation"
            },
            {
                "value": "Quelles sont les bonnes pratiques de conception pour sécuriser un logiciel par rapport à la gestion des erreurs ?",
                "answer": "- Accès refusé par défaut (mettre la variable à false par défaut, et la mettre à true en cas de permission accordée, plutôt que l'inverse)\n- Savoir revenir en arrière en cas d'erreur (ex: garder un historique des actions dans la bd, pour pouvoir inverser un changement non désiré)\n- Checker les valeurs de retour (ex: si on fait open un fichier en C, vérifier que ça retourne pas -1)\n- Gérer les cas non testés (ex: default case dans un switch)\n- Initialiser les variables avec une valeur par défaut\n- Donner un minimum d'informations à l'utilisateur (ex: il n'a pas besoin de voir une stacktrace)"
            },
            {
                "value": "Comment fonctionne l'attaque par \"buffer overflow\" ?",
                "answer": "En assembleur, lorsqu'on appelle une fonction, on va systématiquement commencer par pusher l'adresse de retour (EIP en x86) et le base pointer (EBP en x86).\nComme la stack fonctionne de \"droite à gauche\", à chaque fois qu'on push des valeurs dans la stack, ces deux pointeurs se trouvent sur la droite.\n\nSi maintenant la fonction comporte un input utilisateur (un gets par exemple), le string entré par l'utilisateur sera également pushé sur la stack, à gauche des deux pointeurs mentionnés ci dessus.\nCependant, comme C est débile, si on entre un string trop grand pour rentrer dans l'espace alloué par la stack, la fin du string va aller overrider la stack se trouvant à droite.\n    -> D'où le nom de \"buffer overflow\", on dépasse le buffer initialement alloué à la string pour écraser le reste de la stack\n\nDe cette manière, en entrant un string avec pile la bonne longueur, il est possible de remplacer l'adresse de retour par ce que l'on veut.\n\nL'attaque consiste alors à utiliser le début de la string pour introduire un code binaire valide (shellcode), et de remplacer l'adresse de retour par l'adresse du début de la string ajoutée dans la stack.\nDe cette manière, le code de l'utilisateur sera exécuté (injection de code).\n\nIl y a plusieurs difficultés:\n-> Arriver à créer un shellcode malicieux suffisamment compact pour rentrer dans l'espace alloué au buffer\n-> Trouver l'adresse de début du buffer dans la stack, qui sera l'adresse du shellcode\n-> Trouver le bon nombre de caractères à ajouter (padding) entre le shell code et l'adresse de retour pour que l'override se fasse pile au bon endroit\n\nCette faille peut-être notamment utilisée pour obtenir un accès root."
            },
            {
                "value": "Comment fonctionne l'attaque par \"format string bug\" ?",
                "answer": "En C, la fonction printf permet l'utilisation de différentes \"format string\" permettant d'afficher le contenu de variables.\n\nPar exemple, faire \"printf(\"%x %x\", a, b)\" affiche le contenu des variables a et b au format hexadécimal.\n\nCependant, ces formats ne sont pas vérifiés. Il n'y aura en effet pas d'erreur si on indique trop ou pas assez de variables par rapport au nombre de format string.\n\nAinsi, ceci: \"printf(\"%x %x %x %x\")\" sera exécuté malgré le fait qu'aucune variable n'est spécifiée.\nÀ l'exécution, printf va juste afficher les 4 valeurs suivantes dans la stack, sans se poser la question si c'était bien les valeurs données au printf.\n\nAinsi, il est possible d'afficher le contenu de la stack, ce qui peut révéler des informations qui n'auraient pas dû l'être, ou faciliter une attaque par buffer overflow.\n\nIl y a également une deuxième faille possible avec la fonction printf, en utilisant le format %n qui écrit le nombre de bytes déjà écrits dans un entier dont le pointeur est donné en paramètre.\nCela permet donc de modifier la mémoire étant donné que les paramètres ne sont pas vérifiés !\n\nOn pourrait se dire que ce n'est pas grave si on ne fait pas de C, mais il ne faut pas oublier que le C se cache derrière beaucoup de programmes et langages."
            },
            {
                "value": "Comment fonctionne l'attaque \"return-to-libc\" ?",
                "answer": "C'est une attaque par buffer overflow, sauf qu'au lieu de mettre un shellcode dans la place qu'on a sur le buffer, on va directement renvoyer l'exécution vers une fonction existante dans une librairie, et une autre partie de la pile est modifiée pour lui indiquer des paramètres.\nCela permet par exemple de démarrer d'autres processus, d'accéder au système de fichiers, ..."
            },
            {
                "value": "Comment fonctionne l'attaque par \"return oriented programming\" ?",
                "answer": "C'est une attaque par buffer overflow où l'on va retourner vers des endroits précis du code compilé et pas seulement vers des fonctions précises.\nPar exemple, on pourrait faire retourner le programme au milieu d'une autre fonction qui contient des instructions que l'on souhaite exécuter.\nL'idée va être d'exécuter plein de petits morceaux de code qui ensemble, constitue l'action malicieuse.\n\nPour jumper de morceau en morceau, on peut utiliser des adresses de retour (on peut modifier plusieurs return address dans la stack, donc contrôler où est-ce que ces morceaux de code que l'on exécute vont retourner à leur tour)"
            },
            {
                "value": "Comment peut-on se protéger contre les attaques par buffer overflow ?",
                "answer": "- Empêcher l'exécution du segment de données (ne pas permettre d'exécuter la stack et le heap)\n    -> protège contre l'attaque classique, mais pas contre le return-to-libc ou return oriented programming, étant donné que dans ces deux cas on exécute du code du programme original ou de la libraire standard en ne gérant que les valeurs de retour\n- Utiliser un canary:\n    Un canary est une valeur aléatoire que l'on stocke dans la stack avant l'endroit où les registres sont stockés (entre le buffer et la partie qu'on modifie avec l'overflow). Avant de retourner à la valeur de retour, on vérifie que le canary n'a pas changé (parce que si la valeur de retour a changé, le canary aussi puisqu'il est \"sur le chemin\" en venant du buffer)\n- ASLR (Address Space Layout Randomization)\n    L'espace d'adressage change à chaque exécution d'un processus"
            },
            {
                "value": "Comment fonctionne l'injection de code (haut niveau, comme l'injection SQL) et comment s'en protéger ?",
                "answer": "Fournir au système ce qu'il croit être des données alors qu'en fait, c'est du code.\n-> exécution sans vérification.\n\nExemple le plus connu: Injection SQL (remplir les champs de manière à modifier la requête exécutée, par exemple pour ignorer le mot de passe lors d'une connexion, ou pour insérer des nouvelles requêtes supprimant des lignes...)\nAutres possibilités: LDAP injection, XPATH injection, XML injection...\n\n-> présente dès lors qu'on invoque un environnement d'exécution sans vérifier que les données qu'on lui passe sont valables\n\nSolutions: \n\n- nettoyer les données en escapant les caractères ayant une signification dans le langage (par exemple en sql, escaper les apostrophes)\n    -> il y a généralement des outils prévus pour faire ça, par exemple en SQL il y a moyen de \"préparer\" les requêtes.\n- éviter d'être trop verbeux dans les messages d'erreurs\n- surveiller les logs pour voir s'il y a des essais ratés\n- système de permissions sur la BD: éviter que quelqu'un puisse exécuter n'importe quelle requête"
            },
            {
                "value": "Comment fonctionne l'attaque par Cross Side Scripting (XSS) et comment s'en protéger ?",
                "answer": "Une attaque par Cross Side Scripting (XSS) consiste à inclure dans une page HTML (via un message ou un post de blog par exemple) un script qui sera exécuté sans être validé.\n\nPar exemple, imaginons un site dans lequel les utilisateurs peuvent écrire des messages. Ces messages sont stockés dans la base de données.\nLorsque quelqu'un visite la page, ces messages sont simplement ajoutés dans le html pour qu'ils soient affichés sur la page.\n\nLa faille vient du fait que quelqu'un pourrait écrire un code HTML valide dans un message, qui serait ensuite inclus sans vérification dans le code de la page.\nPour le navigateur, qui affiche la page HTML, il n'y a aucune différence entre un message ajouté depuis la BD et l'HTML original de la page.\nAinsi, un attaquant pourrait inclure dans son message une balise <script> (ou <img>, ou autres...) contenant un code javascript qui serait exécuté chez tous les visiteurs de la page, sans qu'ils s'en aperçoivent.\nIl est alors possible de voler les cookies d'un utilisateur (pour obtenir un cookie de session, par exemple), d'exécuter des requêtes en tant que l'utilisateur, etc.\n\nPour s'en protéger, il faut escaper les caractères spéciaux pour l'HTML, notamment les chevrons < et >.\nPar exemple, on remplace tous les < du message par des &lt; que le navigateur interprétera comme des < et non comme de l'HTML.\n-> il y a des librairies pour ça"
            },
            {
                "value": "Comment fonctionne l'attaque par Client-side validation et comment s'en protéger ?",
                "answer": "L'utilisateur est capable de modifier l'interface (html, javascript...) tant qu'il veut et d'exécuter les requêtes HTTP qu'il veut.\n\n-> Attention à ne pas se fier aux checks réalisés au niveau du front-end !\n\nExemples:\n    - Valeurs prédéfinies dans une liste déroulantes -> on pourrait les modifier/en ajouter\n\nC'est une bonne idée de vérifier les données côté client (pour pouvoir lui afficher des erreurs de saisie rapidement, par exemple) -> ça lui améliore la vie.\n===> Mais il ne faut pas s'y fier pour le côté serveur qui doit aussi tout vérifier !"
            },
            {
                "value": "Comment fonctionne l'attaque par XML eXternal Entity (XXE) et comment s'en protéger ?",
                "answer": "En XML, il y a un mécanisme qui permet de référencer un élement se trouvant à l'extérieur du fichier XML lui-même. (Un genre d'import pour l'XML)\nOn pourrait alors l'utiliser pour récupérer le contenu de n'importe quel fichier XML de la machine.\n-> Il faut vérifier qu'on a bien le droit de le faire, ne pas faire confiance ni à l'utilisateur, ni à l'environnement"
            },
            {
                "value": "Comment fonctionne l'attaque par Directory Traversal et comment s'en protéger ?",
                "answer": "Mauvais filtrage des URL\n-> D'autres fichiers que ceux prévus sont servis par le serveur et on peut y accéder en modifiant l'URL.\n\nPar exemple, si on accède à \"http://monServer.com/myRoute?file=file.txt\", un attaquant pourrait essayer de faire \"http://monServer.com/myRoute?file=../../../etc/passwd\" pour récupérer un autre fichier.\n\nSolutions:\n    - Valider le paramètre\n    - Utiliser une ACL (Access Control List)\n    - Limiter l'accès du programme exécutant le site sur la machine (ex: changer la racine du système de fichier pour que / soit la racine du serveur et non la racine de la machine)"
            },
            {
                "value": "Quelles attaques sont possibles à cause d'une mauvaise gestion des sessions ? Comment s'en protéger ?",
                "answer": "Le protocole HTTP est un protocole sans état (stateless) -> on ne sait pas dire si deux requêtes consécutives viennent d'un même flux (du même endroit)\nPour le savoir, généralement, on utilise des tokens qui sont envoyés à chaque requête:\n    - champ caché dans un form\n    - variables d'URL\n    - Cookies (persistents ou non, secures ou non, ...)\n\nToutes ces valeurs peuvent facilement être modifiées par l'utilisateur\n\n-> éviter les valeurs trop prévisibles\n    Ex: si les id de sessions sont attribués en séquence (ex: il y a le client 1, le client 2, etc...)\n        -> pour se faire passer pour quelqu'un d'autre, on peut facilement deviner son ID\n-> vol de cookie (par XSS par exemple) permet du vol de session\n-> il faut renouveler les id régulièrement\n\nNormalement, les framework web gèrent cet aspect, mais il vaut mieux vérifier."
            },
            {
                "value": "Quels sont les méthodes et outils que l'on peut utiliser pour sécuriser son code ?",
                "answer": "Il y a beaucoup d'outils, il faut les utiliser (après avoir vérifié qu'ils sont fiables):\n\n-> Vérifications du compilateur\n-> Mesures de qualité logicielle\n-> Analyse statique (détecter les mauvaises pratiques les plus récurrentes)\n-> Peer review\n-> Tester !\n    - se mettre dans la peau d'un attaquant et essayer de tout faire casse\n    - Whitebox testing\n    - Blackbox testing\n    - Penetration testing\n    - ..."
            }
        ]
    }
    